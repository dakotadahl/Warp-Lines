<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Line Field</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0506; height: 100vh; height: 100dvh; margin: 0; overflow: visible; }
    .container { 
      position: fixed; 
      left: 0; 
      top: 0;
      width: 100vw; 
      height: 100vh;
      height: 100dvh;
    }
    canvas { display: block; width: 100%; height: 100%; }
    
    /* Fallback for browsers that don't support dvh */
    @supports not (height: 100dvh) {
      .container { 
        height: 100vh;
      }
    }
    
    .gyro-control {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 3000;
      display: none;
    }
    
    @media (hover: none) and (pointer: coarse) {
      .gyro-control {
        display: block !important;
      }
    }
    
    /* Always show on iOS for permission request */
    @supports (-webkit-touch-callout: none) {
      .gyro-control {
        display: block !important;
      }
    }
    
    /* Force show on Safari iOS */
    @media screen and (-webkit-min-device-pixel-ratio: 0) {
      @supports (-webkit-appearance: none) {
        .gyro-control {
          display: block !important;
        }
      }
    }
    
    .gyro-btn {
      background: none;
      border: none;
      color: rgba(253, 87, 75, 0.9);
      padding: 16px 24px;
      font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
      font-size: 12px;
      font-weight: normal;
      text-transform: uppercase;
      letter-spacing: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    
    .gyro-btn:hover {
      color: rgba(253, 87, 75, 1);
    }
    
    .gyro-btn.active {
      color: rgba(253, 87, 75, 1);
    }
    
    .gyro-btn:active {
      opacity: 0.7;
    }
    
    .dev-mode {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2000;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid rgba(253, 87, 75, 0.5);
      border-radius: 12px;
      padding: 20px 24px;
      font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
      font-size: 12px;
      color: rgba(253, 87, 75, 0.9);
      backdrop-filter: blur(10px);
      min-width: 280px;
      display: none;
    }
    
    .dev-mode.active {
      display: block;
    }
    
    .dev-mode h3 {
      margin: 0 0 12px 0;
      font-size: 14px;
      font-weight: 600;
      color: rgba(253, 87, 75, 1);
      border-bottom: 1px solid rgba(253, 87, 75, 0.3);
      padding-bottom: 8px;
    }
    
    .dev-mode .dev-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      line-height: 1.6;
    }
    
    .dev-mode .dev-label {
      color: rgba(253, 87, 75, 0.7);
    }
    
    .dev-mode .dev-value {
      color: rgba(253, 87, 75, 1);
      font-weight: 500;
    }
    
    .dev-mode .dev-section {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(253, 87, 75, 0.2);
    }
  </style>
</head>
<body>
  <div class="container"><canvas id="canvas"></canvas></div>
  <div class="gyro-control">
    <button id="gyroBtn" class="gyro-btn">Enable Gyroscope</button>
  </div>
  <!--
  <div id="devMode" class="dev-mode active">
    <h3>Gyroscope Dev Mode</h3>
    <div class="dev-row">
      <span class="dev-label">Alpha:</span>
      <span class="dev-value" id="devAlpha">0.00°</span>
    </div>
    <div class="dev-row">
      <span class="dev-label">Beta:</span>
      <span class="dev-value" id="devBeta">0.00°</span>
    </div>
    <div class="dev-row">
      <span class="dev-label">Gamma:</span>
      <span class="dev-value" id="devGamma">0.00°</span>
    </div>
    <div class="dev-section">
      <div class="dev-row">
        <span class="dev-label">Δ Alpha:</span>
        <span class="dev-value" id="devDeltaAlpha">0.00°</span>
      </div>
      <div class="dev-row">
        <span class="dev-label">Δ Beta:</span>
        <span class="dev-value" id="devDeltaBeta">0.00°</span>
      </div>
      <div class="dev-row">
        <span class="dev-label">Δ Gamma:</span>
        <span class="dev-value" id="devDeltaGamma">0.00°</span>
      </div>
    </div>
    <div class="dev-section">
      <div class="dev-row">
        <span class="dev-label">Position X:</span>
        <span class="dev-value" id="devPosX">0</span>
      </div>
      <div class="dev-row">
        <span class="dev-label">Position Y:</span>
        <span class="dev-value" id="devPosY">0</span>
      </div>
      <div class="dev-row">
        <span class="dev-label">Velocity X:</span>
        <span class="dev-value" id="devVelX">0.00</span>
      </div>
      <div class="dev-row">
        <span class="dev-label">Velocity Y:</span>
        <span class="dev-value" id="devVelY">0.00</span>
      </div>
    </div>
    <div class="dev-section">
      <div class="dev-row">
        <span class="dev-label">Enabled:</span>
        <span class="dev-value" id="devEnabled">false</span>
      </div>
      <div class="dev-row">
        <span class="dev-label">Calibrated:</span>
        <span class="dev-value" id="devCalibrated">false</span>
      </div>
      <div class="dev-row">
        <span class="dev-label">Active:</span>
        <span class="dev-value" id="devActive">false</span>
      </div>
    </div>
  </div>
  -->
  <script>
    (function() {
      'use strict';

      // ============================================================================
      // Performance Configuration & Feature Flags
      // ============================================================================
      const DEBUG = false; // Set to true for development debugging
      const log = DEBUG ? console.log.bind(console) : function() {};
      const logError = DEBUG ? console.error.bind(console) : function() {};
      const logWarn = DEBUG ? console.warn.bind(console) : function() {};

      // Adaptive quality detection
      const isLowEndDevice = (() => {
        const hardwareConcurrency = navigator.hardwareConcurrency || 4;
        const deviceMemory = navigator.deviceMemory || 4;
        return hardwareConcurrency < 4 || deviceMemory < 4;
      })();

      // Frame rate limiting
      let lastFrameTime = 0;
      const targetFPS = 60;
      const frameInterval = 1000 / targetFPS;

      // Page visibility state
      let isPaused = false;

      // Dev mode update throttling
      let devModeFrameCount = 0;
      const DEV_MODE_UPDATE_INTERVAL = 10; // Update every 10 frames

      // ============================================================================
      // Configuration
      // ============================================================================
    const CONFIG = {
      pointsPerLine: 60,
      color: { r: 253, g: 87, b: 75 },
      lineWidth: 0.5,
      cursorRadius: 180,
      dragStrength: 16,
      baseStrength: 300,
      wakeLength: 200,
      wakeLengthSquared: 200 * 200, // Pre-calculated for distance comparisons
      velocitySmoothing: 0.15,
      mouseSmoothing: 0.12,
      noiseTimeScale: 0.0000008,
      noiseAmplitude: 8,
      driftSpeed: 0.00000002,
      driftAmplitude: 4,
      driftWaveLength: 0.008,
      vanishingPointY: 0.95,
      // Performance thresholds
      minVelocityForWake: 0.3,
      maxCursorDistance: 600,
      maxCursorDistanceSquared: 600 * 600,
      easeFactorMin: 0.002,
      easeFactorMax: 0.02,
      easeFactorDivisor: 800,
      // Fluidity enhancements
      springStrength: 0.15,        // Connection between adjacent points
      springDamping: 0.85,          // Damping for spring effect
      waveInfluence: 0.08,          // How much nearby lines influence each other
      waveRadius: 80,               // Distance for wave propagation
      waveRadiusSquared: 80 * 80,
      verticalFlow: 0.3,            // Subtle downward current
      flowSpeed: 0.00001,           // Speed of vertical flow
      pointVelocityDamping: 0.92,    // Momentum persistence
      curlStrength: 0.4,            // Rotation effect around cursor
      turbulenceScale: 0.003        // Additional noise for turbulence
    };

    const GYRO_LIQUID_CONFIG = {
      tiltSensitivity: 0.002, // Dramatically increased for more dramatic acceleration
      damping: 0.94, // Less damping for more dramatic movement
      springStrength: 0.0004, // Much stronger spring for snappier response
      maxVelocity: 25, // Much faster max velocity for dramatic movement
      overshootFactor: 1.15,
      oscillationDamping: 0.92,
      waveFrequency: 0.004, // Faster oscillation
      waveAmplitude: 0.4 // Moderate wave amplitude (split difference)
    };

      // ============================================================================
      // WebGL Setup
      // ============================================================================
      const canvas = document.getElementById('canvas');
      if (!canvas) {
        logError('Canvas element not found');
        return;
      }
      
      // Try WebGL first, fallback to 2D canvas
      let gl = null;
      let useWebGL = false;
      let ctx = null;
      
      try {
        gl = canvas.getContext('webgl', { 
          alpha: false, 
          antialias: true,
          depth: false,
          stencil: false,
          preserveDrawingBuffer: false
        }) || canvas.getContext('experimental-webgl', { alpha: false });
        
        if (gl) {
          useWebGL = true;
          log('WebGL context created successfully');
        }
      } catch (e) {
        logError('WebGL not available, falling back to Canvas 2D:', e);
      }
      
      // Fallback to Canvas 2D if WebGL failed
      if (!useWebGL) {
        ctx = canvas.getContext('2d', { alpha: false });
        log('Using Canvas 2D fallback');
      }
      
      // Cache color values
      const strokeColor = `rgba(${CONFIG.color.r},${CONFIG.color.g},${CONFIG.color.b},0.85)`;
      const bgColor = '#0a0506';
      const strokeColorRGB = [CONFIG.color.r / 255, CONFIG.color.g / 255, CONFIG.color.b / 255, 0.85];
      const bgColorRGB = [10 / 255, 5 / 255, 6 / 255, 1.0];
      
      // WebGL shaders and buffers
      let shaderProgram = null;
      let positionBuffer = null;
      let vertexCount = 0;
      
      if (useWebGL) {
        // Vertex shader source
        const vertexShaderSource = `
          attribute vec2 a_position;
          uniform vec2 u_resolution;
          
          void main() {
            // Convert from pixels to clip space
            vec2 clipSpace = ((a_position / u_resolution) * 2.0) - 1.0;
            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
          }
        `;
        
        // Fragment shader source
        const fragmentShaderSource = `
          precision mediump float;
          uniform vec4 u_color;
          
          void main() {
            gl_FragColor = u_color;
          }
        `;
        
        // Compile shader
        function createShader(gl, type, source) {
          const shader = gl.createShader(type);
          gl.shaderSource(shader, source);
          gl.compileShader(shader);
          
          if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            logError('Shader compilation error:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
          }
          
          return shader;
        }
        
        // Create shader program
        function createProgram(gl, vertexSource, fragmentSource) {
          const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
          const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
          
          if (!vertexShader || !fragmentShader) {
            return null;
          }
          
          const program = gl.createProgram();
          gl.attachShader(program, vertexShader);
          gl.attachShader(program, fragmentShader);
          gl.linkProgram(program);
          
          if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            logError('Program linking error:', gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
          }
          
          return program;
        }
        
        shaderProgram = createProgram(gl, vertexShaderSource, fragmentShaderSource);
        
        if (shaderProgram) {
          // Get attribute and uniform locations
          const positionLocation = gl.getAttribLocation(shaderProgram, 'a_position');
          const resolutionLocation = gl.getUniformLocation(shaderProgram, 'u_resolution');
          const colorLocation = gl.getUniformLocation(shaderProgram, 'u_color');
          
          // Create position buffer
          positionBuffer = gl.createBuffer();
          
          // WebGL state setup
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
          gl.lineWidth(1.0); // Note: lineWidth may be limited to 1.0 on some systems
          
          // Store locations for later use
          gl.positionLocation = positionLocation;
          gl.resolutionLocation = resolutionLocation;
          gl.colorLocation = colorLocation;
          
          log('WebGL setup complete');
        } else {
          logError('Failed to create WebGL program, falling back to Canvas 2D');
          useWebGL = false;
          ctx = canvas.getContext('2d', { alpha: false });
        }
      }

    // ============================================================================
    // Noise Generator (Simplex Noise)
    // ============================================================================
    const noise = (() => {
      const perm = new Uint8Array(512);
      for (let i = 0; i < 256; i++) {
        perm[i] = perm[i + 256] = Math.floor(Math.random() * 256);
      }
      
      const grad3 = [
        [1,1,0], [-1,1,0], [1,-1,0], [-1,-1,0],
        [1,0,1], [-1,0,1], [1,0,-1], [-1,0,-1],
        [0,1,1], [0,-1,1], [0,1,-1], [0,-1,-1]
      ];
      
      const dot = (g, x, y) => g[0] * x + g[1] * y;
      const fade = (t) => t * t * t * (t * (t * 6 - 15) + 10);
      const lerp = (a, b, t) => a + t * (b - a);
      
      return (x, y) => {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        
        const u = fade(x);
        const v = fade(y);
        const A = perm[X] + Y;
        const B = perm[X + 1] + Y;
        
        return lerp(
          lerp(
            dot(grad3[perm[A] % 12], x, y),
            dot(grad3[perm[B] % 12], x - 1, y),
            u
          ),
          lerp(
            dot(grad3[perm[A + 1] % 12], x, y - 1),
            dot(grad3[perm[B + 1] % 12], x - 1, y - 1),
            u
          ),
          v
        );
      };
    })();

    // ============================================================================
    // State Management
    // ============================================================================
    let width = 0;
    let height = 0;
    let lines = [];
    
    const mouse = { x: -1000, y: -1000 };
    const targetMouse = { x: -1000, y: -1000 };
    const prevMouse = { x: -1000, y: -1000 };
    const velocity = { x: 0, y: 0 };
    
    // Gyroscope state
    let gyroEnabled = false;
    let gyroCalibrated = false;
    let gyroCalibration = { alpha: 0, beta: 0, gamma: 0 };
    let gyroTarget = { x: -1000, y: -1000 };
    let gyroPosition = { x: 0, y: 0 };
    let gyroVelocity = { x: 0, y: 0 };
    let gyroAcceleration = { x: 0, y: 0 };
    let useGyro = false;
    let gyroValidated = false;
    let gyroValidationSamples = [];
    let gyroValidationStartTime = 0;
    let isAutoEnabled = false;
    
    let currentGyroValues = { alpha: 0, beta: 0, gamma: 0 };
    let currentGyroDeltas = { alpha: 0, beta: 0, gamma: 0 };
    
    let time = 0;
    const vanishingPoint = { x: 0, y: 0 };

    // ============================================================================
    // Line Initialization
    // ============================================================================
      function initLines() {
        lines = [];
        
        // Adaptive quality: reduce complexity on low-end devices
        const originalLineCount = 200;
        const qualityMultiplier = isLowEndDevice ? 0.8 : 1.4; // Reduce lines on low-end
        const targetLineCount = Math.ceil(originalLineCount * qualityMultiplier);
        const spacing = width / (targetLineCount + 1);
        
        // Adaptive point count per line
        const pointsPerLine = isLowEndDevice ? Math.floor(CONFIG.pointsPerLine * 0.8) : CONFIG.pointsPerLine;
      const pointStep = 1 / (pointsPerLine - 1);
      
      for (let i = 0; i < targetLineCount; i++) {
        const canvasX = spacing * (i + 1);
        const normalizedX = (i + 1) / (targetLineCount + 1);
        
        const line = {
          points: [],
          restPoints: [],
          index: i,
          normalizedX
        };
        
        // Pre-calculate point positions
        for (let j = 0; j < pointsPerLine; j++) {
          const t = j * pointStep;
          const y = t * height;
          const point = { x: canvasX, y, vx: 0, vy: 0 }; // Add velocity for momentum
          const restPoint = { x: canvasX, y, normalizedY: t };
          
          line.points.push(point);
          line.restPoints.push(restPoint);
        }
        
        lines.push(line);
      }
    }

      // ============================================================================
      // Resize Handler
      // ============================================================================
      function resize() {
        const dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight; // Exactly 100vh
        
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        
        if (useWebGL && gl) {
          gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        } else if (ctx) {
          ctx.scale(dpr, dpr);
        }
        
        vanishingPoint.x = width / 2;
        vanishingPoint.y = height * CONFIG.vanishingPointY;
      
      if (gyroTarget.x === -1000) {
        const centerX = width / 2;
        const centerY = height / 2;
        gyroTarget.x = centerX;
        gyroTarget.y = centerY;
        gyroPosition.x = centerX;
        gyroPosition.y = centerY;
      } else if (gyroCalibrated) {
        const centerX = width / 2;
        const centerY = height / 2;
        gyroPosition.x = centerX;
        gyroPosition.y = centerY;
        gyroTarget.x = centerX;
        gyroTarget.y = centerY;
      }
      
      initLines();
    }

      // ============================================================================
      // Point Update Logic
      // ============================================================================
      function updatePoints() {
      updateGyroscopePhysics();
      
      if (useGyro && gyroEnabled && gyroCalibrated) {
        // Use gyroPosition (smoothed physics position) instead of gyroTarget
        targetMouse.x = gyroPosition.x;
        targetMouse.y = gyroPosition.y;
      }
      
      // Update mouse position with smoothing
      prevMouse.x = mouse.x;
      prevMouse.y = mouse.y;
      mouse.x += (targetMouse.x - mouse.x) * CONFIG.mouseSmoothing;
      mouse.y += (targetMouse.y - mouse.y) * CONFIG.mouseSmoothing;
      
      // Update velocity
      const mouseDeltaX = mouse.x - prevMouse.x;
      const mouseDeltaY = mouse.y - prevMouse.y;
      velocity.x += (mouseDeltaX - velocity.x) * CONFIG.velocitySmoothing;
      velocity.y += (mouseDeltaY - velocity.y) * CONFIG.velocitySmoothing;
      
      // Pre-calculate time-based values
      const timeNoiseX = time * CONFIG.noiseTimeScale;
      const timeNoiseY = timeNoiseX * 0.7;
      const timeDrift = time * CONFIG.driftSpeed * 1000;
      const velMagSquared = velocity.x * velocity.x + velocity.y * velocity.y;
      const velMag = Math.sqrt(velMagSquared);
      const hasVelocity = velMag > CONFIG.minVelocityForWake;
      
      // Cache constants
      const wakeLength = CONFIG.wakeLength;
      const wakeLengthSquared = CONFIG.wakeLengthSquared;
      const maxCursorDistSquared = CONFIG.maxCursorDistanceSquared;
      const noiseAmp = CONFIG.noiseAmplitude;
      const driftAmp = CONFIG.driftAmplitude;
      const baseStrength = CONFIG.baseStrength;
      const dragStrength = CONFIG.dragStrength;
      
      // Pre-calculate vertical flow effect
      const verticalFlowOffset = Math.sin(time * CONFIG.flowSpeed) * CONFIG.verticalFlow;
      
      // Update each line
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const normalizedX = line.normalizedX;
        const noiseX = normalizedX * 3 + timeNoiseX;
        
        // Pre-calculate noise and drift for this line
        const driftBase = Math.sin(normalizedX * Math.PI * 6 + timeDrift) * driftAmp;
        
        // Get neighboring lines for wave influence
        const prevLine = i > 0 ? lines[i - 1] : null;
        const nextLine = i < lines.length - 1 ? lines[i + 1] : null;
        const waveStrength = CONFIG.waveInfluence;
        
        // Update each point in the line
        for (let j = 0; j < line.points.length; j++) {
          const rest = line.restPoints[j];
          const point = line.points[j];
          
          // Calculate wave influence from neighboring lines at this point height
          let neighborInfluenceX = 0;
          if (prevLine && nextLine && j < prevLine.points.length && j < nextLine.points.length) {
            const prevPoint = prevLine.points[j];
            const nextPoint = nextLine.points[j];
            const dxPrev = prevPoint.x - rest.x;
            const dxNext = nextPoint.x - rest.x;
            neighborInfluenceX = (dxPrev + dxNext) * waveStrength * 0.5;
          }
          
          // Calculate ambient noise effect with turbulence
          const noiseVal = noise(noiseX, rest.normalizedY * 2 + timeNoiseY);
          const turbulenceVal = noise(
            normalizedX * 5 + time * CONFIG.turbulenceScale,
            rest.normalizedY * 3 + time * CONFIG.turbulenceScale * 0.5
          ) * 0.3;
          
          // Distance from cursor (using squared distance to avoid sqrt)
          const dxFromCursor = rest.x - mouse.x;
          const dyFromCursor = rest.y - mouse.y;
          const distFromCursorSquared = dxFromCursor * dxFromCursor + dyFromCursor * dyFromCursor;
          
          // Ambient effect (only calculate if cursor is nearby)
          let ambientX = 0;
          let ambientY = verticalFlowOffset; // Add vertical flow
          
          if (distFromCursorSquared < maxCursorDistSquared) {
            const distFromCursor = Math.sqrt(distFromCursorSquared);
            const ambientScale = 0.3 + (1 - distFromCursor / CONFIG.maxCursorDistance) * 2;
            const dirX = distFromCursor > 0 ? dxFromCursor / distFromCursor : 0;
            const dirY = distFromCursor > 0 ? dyFromCursor / distFromCursor : 0;
            
            // Add curl/rotation effect around cursor
            const curlAngle = Math.atan2(dyFromCursor, dxFromCursor) + Math.PI / 2;
            const curlX = Math.cos(curlAngle) * CONFIG.curlStrength * ambientScale;
            const curlY = Math.sin(curlAngle) * CONFIG.curlStrength * ambientScale;
            
            ambientX = (noiseVal * noiseAmp + driftBase + turbulenceVal) * ambientScale * dirX + curlX;
            ambientY += curlY * 0.5;
          } else {
            // Subtle ambient flow even when cursor is far
            ambientX = (noiseVal * noiseAmp + driftBase + turbulenceVal) * 0.3;
          }
          
          // Add wave influence from neighbors
          ambientX += neighborInfluenceX;
          
          // Calculate drag effect
          const dx = rest.x - mouse.x;
          const dy = rest.y - mouse.y;
          const distSquared = dx * dx + dy * dy;
          
          let dragOffsetX = 0;
          let dragOffsetY = 0;
          
          if (distSquared < wakeLengthSquared && hasVelocity) {
            const dist = Math.sqrt(distSquared);
            const distFalloff = Math.pow(1 - dist / wakeLength, 2);
            
            const invDist = 1 / Math.max(dist, 1);
            const pushX = dx * invDist;
            const pushY = dy * invDist;
            
            const dragInfluence = Math.min(velMag / 5, 1);
            const invVelMag = 1 / velMag;
            const blendedX = pushX * (1 - dragInfluence * 0.7) + velocity.x * invVelMag * dragInfluence;
            const blendedY = pushY * (1 - dragInfluence * 0.7) + velocity.y * invVelMag * dragInfluence;
            
            const velFactor = Math.min(velMag / 4, 1);
            const strength = (baseStrength * velFactor * velFactor + velMag * dragStrength) * distFalloff;
            
            dragOffsetX = blendedX * strength;
            dragOffsetY = blendedY * strength * 0.4;
          }
          
          // Calculate target position
          const targetX = rest.x + ambientX + dragOffsetX;
          const targetY = rest.y + ambientY + dragOffsetY;
          
          // Spring connection to adjacent points for fluidity
          let springForceX = 0;
          let springForceY = 0;
          
          if (j > 0) {
            const prevPoint = line.points[j - 1];
            const springDX = prevPoint.x - point.x;
            const springDY = prevPoint.y - point.y;
            springForceX += springDX * CONFIG.springStrength;
            springForceY += springDY * CONFIG.springStrength;
          }
          
          if (j < line.points.length - 1) {
            const nextPoint = line.points[j + 1];
            const springDX = nextPoint.x - point.x;
            const springDY = nextPoint.y - point.y;
            springForceX += springDX * CONFIG.springStrength;
            springForceY += springDY * CONFIG.springStrength;
          }
          
          // Apply momentum (velocity persistence)
          point.vx *= CONFIG.pointVelocityDamping;
          point.vy *= CONFIG.pointVelocityDamping;
          
          // Calculate forces
          const diffX = targetX - point.x;
          const diffY = targetY - point.y;
          const diffSquared = diffX * diffX + diffY * diffY;
          const diffMag = Math.sqrt(diffSquared);
          
          // Adaptive easing for smoother motion
          const easeFactor = CONFIG.easeFactorMin + Math.min(diffMag / CONFIG.easeFactorDivisor, CONFIG.easeFactorMax);
          
          // Add spring forces to velocity
          point.vx += (diffX * easeFactor + springForceX) * (1 - CONFIG.springDamping);
          point.vy += (diffY * easeFactor + springForceY) * (1 - CONFIG.springDamping);
          
          // Apply velocity with damping
          point.x += point.vx;
          point.y += point.vy;
          
          // Also apply direct easing for responsiveness
          point.x += diffX * easeFactor * CONFIG.springDamping;
          point.y += diffY * easeFactor * CONFIG.springDamping;
        }
      }

      // ============================================================================
      // Rendering
      // ============================================================================
      // Helper function to tessellate quadratic curve into line segments
      function tessellateQuadratic(p0x, p0y, p1x, p1y, p2x, p2y, segments = 8) {
        const result = [];
        // Skip first point (p0) as it's already added
        for (let i = 1; i <= segments; i++) {
          const t = i / segments;
          const mt = 1 - t;
          const x = mt * mt * p0x + 2 * mt * t * p1x + t * t * p2x;
          const y = mt * mt * p0y + 2 * mt * t * p1y + t * t * p2y;
          result.push(x, y);
        }
        return result;
      }
      
      function drawLine(points) {
        if (points.length < 2) return;
        
        if (useWebGL && gl) {
          // WebGL rendering - tessellate curves for smooth appearance
          const segments = [];
          const lastIndex = points.length - 1;
          
          // Add first point
          segments.push(points[0].x, points[0].y);
          
          // Create smooth curve segments matching Canvas 2D quadraticCurveTo behavior
          for (let i = 1; i < lastIndex; i++) {
            const prev = i === 1 ? points[0] : points[i - 1];
            const current = points[i];
            const next = points[i + 1];
            
            // Calculate midpoint for quadratic curve (matches Canvas 2D logic)
            const midX = (current.x + next.x) * 0.5;
            const midY = (current.y + next.y) * 0.5;
            
            // Tessellate the quadratic curve (prev -> current -> mid)
            // This matches: ctx.quadraticCurveTo(current.x, current.y, midX, midY)
            const curveSegments = tessellateQuadratic(
              prev.x, prev.y,      // Start point
              current.x, current.y, // Control point
              midX, midY,          // End point
              6 // Number of segments per curve (adjust for quality/performance)
            );
            
            // Add tessellated segments
            segments.push(...curveSegments);
          }
          
          // Add last point
          segments.push(points[lastIndex].x, points[lastIndex].y);
          
          return segments;
        } else {
          // Canvas 2D fallback
          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);
          
          const lastIndex = points.length - 1;
          for (let i = 1; i < lastIndex; i++) {
            const current = points[i];
            const next = points[i + 1];
            const midX = (current.x + next.x) * 0.5;
            const midY = (current.y + next.y) * 0.5;
            ctx.quadraticCurveTo(current.x, current.y, midX, midY);
          }
          
          const last = points[lastIndex];
          ctx.lineTo(last.x, last.y);
          ctx.stroke();
          return null;
        }
      }
      
      function renderWebGL() {
        if (!gl || !shaderProgram) return;
        
        // Clear canvas
        gl.clearColor(bgColorRGB[0], bgColorRGB[1], bgColorRGB[2], bgColorRGB[3]);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        // Use shader program
        gl.useProgram(shaderProgram);
        
        // Set resolution uniform
        gl.uniform2f(gl.resolutionLocation, width, height);
        
        // Set color uniform
        gl.uniform4f(gl.colorLocation, strokeColorRGB[0], strokeColorRGB[1], strokeColorRGB[2], strokeColorRGB[3]);
        
        // Bind position buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(gl.positionLocation);
        gl.vertexAttribPointer(gl.positionLocation, 2, gl.FLOAT, false, 0, 0);
        
        // Collect all line vertices
        const allVertices = [];
        const lineStarts = [];
        let vertexOffset = 0;
        
        for (let i = 0; i < lines.length; i++) {
          const lineSegments = drawLine(lines[i].points);
          if (lineSegments && lineSegments.length >= 4) { // Need at least 2 points (4 values)
            const pointCount = lineSegments.length / 2;
            lineStarts.push({
              offset: vertexOffset,
              count: pointCount
            });
            allVertices.push(...lineSegments);
            vertexOffset += pointCount;
          }
        }
        
        if (allVertices.length > 0) {
          // Upload vertex data
          const vertices = new Float32Array(allVertices);
          gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
          
          // Draw each line as a line strip
          for (let i = 0; i < lineStarts.length; i++) {
            const line = lineStarts[i];
            if (line.count > 1) {
              gl.drawArrays(gl.LINE_STRIP, line.offset, line.count);
            }
          }
        }
      }

      function render(timestamp) {
        // Frame rate limiting
        const elapsed = timestamp - lastFrameTime;
        if (elapsed < frameInterval) {
          requestAnimationFrame(render);
          return;
        }
        lastFrameTime = timestamp - (elapsed % frameInterval);

        // Pause when page is hidden
        if (isPaused) {
          requestAnimationFrame(render);
          return;
        }

        time = timestamp;
        
        // Update physics
        updatePoints();
        
        // Render based on context type
        if (useWebGL && gl) {
          renderWebGL();
        } else if (ctx) {
          // Canvas 2D fallback
          ctx.fillStyle = bgColor;
          ctx.fillRect(0, 0, width, height);
          
          // Batch canvas state changes - set once before loop
          ctx.strokeStyle = strokeColor;
          ctx.lineWidth = CONFIG.lineWidth;
          
          for (let i = 0; i < lines.length; i++) {
            drawLine(lines[i].points);
          }
        }
        
        // Throttle dev mode updates (every N frames)
        if (devModeFrameCount % DEV_MODE_UPDATE_INTERVAL === 0) {
          updateDevMode();
        }
        devModeFrameCount++;
        
        requestAnimationFrame(render);
      }

      // ============================================================================
      // Gyroscope Functions
      // ============================================================================
      function requestGyroPermission() {
        log('requestGyroPermission called');
        log('DeviceOrientationEvent available:', typeof DeviceOrientationEvent !== 'undefined');
        log('requestPermission available:', typeof DeviceOrientationEvent !== 'undefined' && 
                    typeof DeviceOrientationEvent.requestPermission === 'function');
      
        if (typeof DeviceOrientationEvent !== 'undefined' && 
            typeof DeviceOrientationEvent.requestPermission === 'function') {
          log('Calling DeviceOrientationEvent.requestPermission()');
          try {
            const permissionPromise = DeviceOrientationEvent.requestPermission();
            log('Permission promise created:', permissionPromise);
            
            permissionPromise
              .then(response => {
                log('Permission response:', response);
                if (response === 'granted') {
                  enableGyroscope(true); // Auto-enable on permission grant
                  // Add event listener after permission is granted
                  // Remove first in case it was already added
                  window.removeEventListener('deviceorientation', handleDeviceOrientation);
                  window.addEventListener('deviceorientation', handleDeviceOrientation, { passive: true });
                  log('Device orientation permission granted');
                
                // Update button if it exists (optional) - will be updated to "Validating..." after first calibration
                const gyroBtn = document.getElementById('gyroBtn');
                if (gyroBtn) {
                  gyroBtn.textContent = 'Waiting for calibration...';
                  gyroBtn.disabled = false;
                }
                } else {
                  logWarn('Device orientation permission denied, response:', response);
                  // Update button if it exists (optional)
                  const gyroBtn = document.getElementById('gyroBtn');
                  if (gyroBtn) {
                    gyroBtn.textContent = 'Permission Denied - Tap to Retry';
                    gyroBtn.disabled = false;
                  }
                }
              })
              .catch(error => {
                logError('Error requesting device orientation permission:', error);
                // Update button if it exists (optional)
                const gyroBtn = document.getElementById('gyroBtn');
                if (gyroBtn) {
                  gyroBtn.textContent = 'Error - Tap to Retry';
                  gyroBtn.disabled = false;
                }
              });
          } catch (error) {
            logError('Exception calling requestPermission:', error);
            // Update button if it exists (optional)
            const gyroBtn = document.getElementById('gyroBtn');
            if (gyroBtn) {
              gyroBtn.textContent = 'Exception - Check Console';
              gyroBtn.disabled = false;
            }
            throw error; // Re-throw so caller knows it failed
          }
        } else {
          log('requestPermission not available, enabling directly');
          enableGyroscope(true);
        }
      }

      function enableGyroscope(autoEnable = false) {
        gyroEnabled = true;
        gyroCalibrated = false;
        gyroValidated = false;
        gyroValidationSamples = [];
        gyroValidationStartTime = Date.now();
        isAutoEnabled = autoEnable;
        log('Gyroscope enabled, autoEnable:', autoEnable);
      }

      function calibrateGyroscope(alpha, beta, gamma) {
        gyroCalibration.alpha = alpha || 0;
        gyroCalibration.beta = beta || 0;
        gyroCalibration.gamma = gamma || 0;
        gyroCalibrated = true;
        log('Gyroscope calibrated:', { alpha, beta, gamma });
        if (isAutoEnabled) {
          useGyro = true;
          log('Gyroscope auto-enabled');
        }
      }

      function validateGyroscopeInput(e) {
      if (gyroValidated) return true;
      
      const alpha = e.alpha;
      const beta = e.beta;
      const gamma = e.gamma;
      
      if (alpha === null || alpha === undefined ||
          beta === null || beta === undefined ||
          gamma === null || gamma === undefined) {
        return false;
      }
      
      gyroValidationSamples.push({ alpha, beta, gamma, timestamp: Date.now() });
      
      const oneSecondAgo = Date.now() - 1000;
      gyroValidationSamples = gyroValidationSamples.filter(s => s.timestamp > oneSecondAgo);
      
      if (gyroValidationSamples.length < 5) {
        return false;
      }
      
      let maxAlphaDiff = 0;
      let maxBetaDiff = 0;
      let maxGammaDiff = 0;
      
      for (let i = 1; i < gyroValidationSamples.length; i++) {
        const prev = gyroValidationSamples[i - 1];
        const curr = gyroValidationSamples[i];
        
        const alphaDiff = Math.abs(curr.alpha - prev.alpha);
        const betaDiff = Math.abs(curr.beta - prev.beta);
        const gammaDiff = Math.abs(curr.gamma - prev.gamma);
        
        const normalizedAlphaDiff = Math.min(alphaDiff, 360 - alphaDiff);
        
        maxAlphaDiff = Math.max(maxAlphaDiff, normalizedAlphaDiff);
        maxBetaDiff = Math.max(maxBetaDiff, betaDiff);
        maxGammaDiff = Math.max(maxGammaDiff, gammaDiff);
      }
      
      const validationDuration = Date.now() - gyroValidationStartTime;
      const hasVariation = maxAlphaDiff > 0.5 || maxBetaDiff > 0.5 || maxGammaDiff > 0.5;
      const hasEnoughTime = validationDuration > 2000;
      const hasEnoughSamples = gyroValidationSamples.length >= 5;
      
      // Validate if we have variation, enough time has passed, or enough samples (even without variation)
        if (hasVariation || hasEnoughTime || (hasEnoughSamples && validationDuration > 1000)) {
          gyroValidated = true;
          useGyro = true;
          log('Gyroscope validated:', { 
            hasVariation, 
            hasEnoughTime, 
            hasEnoughSamples, 
            samples: gyroValidationSamples.length,
            duration: validationDuration 
          });
        
        const gyroControl = document.querySelector('.gyro-control');
        
        // Update button
        const gyroBtn = document.getElementById('gyroBtn');
        if (gyroBtn) {
          // On mobile devices, hide the button immediately once gyroscope is enabled and validated
          // This prevents users from accidentally disabling it and ensures "Disable Gyroscope" never appears
          if (hasGyroscope) {
            // Hide button immediately with multiple CSS properties to ensure it's completely hidden
            if (gyroControl) {
              gyroControl.style.setProperty('display', 'none', 'important');
              gyroControl.style.setProperty('visibility', 'hidden', 'important');
              gyroControl.style.setProperty('opacity', '0', 'important');
              gyroControl.style.setProperty('pointer-events', 'none', 'important');
            }
            // Never set "Disable Gyroscope" text on mobile - button should be hidden
            log('Gyroscope validated on mobile - hiding button to prevent disable');
            return true; // Early return to prevent any further button updates
          }
          
          // Desktop: show button with toggle option
          setGyroButtonText('Disable Gyroscope');
          gyroBtn.classList.add('active');
          gyroBtn.disabled = false;
          if (gyroControl) {
            gyroControl.style.display = 'none';
          }
        }
        
        return true;
      }
      
      return false;
    }

      function updateDevMode() {
        const devMode = document.getElementById('devMode');
        if (!devMode) return;
      
      const alphaEl = document.getElementById('devAlpha');
      const betaEl = document.getElementById('devBeta');
      const gammaEl = document.getElementById('devGamma');
      
      if (alphaEl) alphaEl.textContent = currentGyroValues.alpha.toFixed(2) + '°';
      if (betaEl) betaEl.textContent = currentGyroValues.beta.toFixed(2) + '°';
      if (gammaEl) gammaEl.textContent = currentGyroValues.gamma.toFixed(2) + '°';
      
      const deltaAlphaEl = document.getElementById('devDeltaAlpha');
      const deltaBetaEl = document.getElementById('devDeltaBeta');
      const deltaGammaEl = document.getElementById('devDeltaGamma');
      
      if (deltaAlphaEl) {
        let deltaAlpha = currentGyroDeltas.alpha;
        if (deltaAlpha > 180) deltaAlpha -= 360;
        if (deltaAlpha < -180) deltaAlpha += 360;
        deltaAlphaEl.textContent = deltaAlpha.toFixed(2) + '°';
      }
      if (deltaBetaEl) deltaBetaEl.textContent = currentGyroDeltas.beta.toFixed(2) + '°';
      if (deltaGammaEl) deltaGammaEl.textContent = currentGyroDeltas.gamma.toFixed(2) + '°';
      
      const posXEl = document.getElementById('devPosX');
      const posYEl = document.getElementById('devPosY');
      const velXEl = document.getElementById('devVelX');
      const velYEl = document.getElementById('devVelY');
      
      if (posXEl) posXEl.textContent = Math.round(gyroPosition.x);
      if (posYEl) posYEl.textContent = Math.round(gyroPosition.y);
      if (velXEl) velXEl.textContent = gyroVelocity.x.toFixed(2);
      if (velYEl) velYEl.textContent = gyroVelocity.y.toFixed(2);
      
      const enabledEl = document.getElementById('devEnabled');
      const calibratedEl = document.getElementById('devCalibrated');
      const activeEl = document.getElementById('devActive');
      
      if (enabledEl) enabledEl.textContent = gyroEnabled ? 'true' : 'false';
      if (calibratedEl) calibratedEl.textContent = gyroCalibrated ? 'true' : 'false';
      if (activeEl) activeEl.textContent = useGyro ? 'true' : 'false';
    }

      function handleDeviceOrientation(e) {
      // On iOS, if we receive an event, permission is granted
      if (!gyroEnabled) {
        const alpha = e.alpha;
        const beta = e.beta;
        const gamma = e.gamma;
        
        const hasValidData = (alpha !== null && alpha !== undefined) ||
                            (beta !== null && beta !== undefined) ||
                            (gamma !== null && gamma !== undefined);
        
        if (hasValidData) {
          enableGyroscope(true);
          const gyroBtn = document.getElementById('gyroBtn');
          if (gyroBtn) {
            gyroBtn.textContent = 'Enable Gyroscope';
            gyroBtn.disabled = false;
          }
        } else {
          return;
        }
      }
      
      validateGyroscopeInput(e);
      
      const alpha = e.alpha !== null ? e.alpha : 0;
      const beta = e.beta !== null ? e.beta : 0;
      const gamma = e.gamma !== null ? e.gamma : 0;
      
      currentGyroValues.alpha = alpha;
      currentGyroValues.beta = beta;
      currentGyroValues.gamma = gamma;
      
      if (!gyroCalibrated) {
        calibrateGyroscope(alpha, beta, gamma);
        const centerX = width / 2;
        const centerY = height / 2;
        gyroTarget.x = centerX;
        gyroTarget.y = centerY;
        gyroPosition.x = centerX;
        gyroPosition.y = centerY;
        gyroVelocity.x = 0;
        gyroVelocity.y = 0;
        currentGyroDeltas.alpha = 0;
        currentGyroDeltas.beta = 0;
        currentGyroDeltas.gamma = 0;
        updateDevMode();
        
        // Update button text after calibration
        const gyroBtn = document.getElementById('gyroBtn');
        if (gyroBtn) {
          // On mobile, don't show "Validating..." if button should be hidden soon
          // Just keep it as-is or hide it immediately
          if (!hasGyroscope) {
            gyroBtn.textContent = 'Validating...';
          }
          gyroBtn.disabled = false;
        }
        
        return;
      }
      
      const deltaAlpha = alpha - gyroCalibration.alpha;
      const deltaBeta = beta - gyroCalibration.beta;
      const deltaGamma = gamma - gyroCalibration.gamma;
      
      currentGyroDeltas.alpha = deltaAlpha;
      currentGyroDeltas.beta = deltaBeta;
      currentGyroDeltas.gamma = deltaGamma;
      
      updateDevMode();
      
      if (!useGyro) return;
      
      let normalizedAlpha = deltaAlpha;
      if (normalizedAlpha > 180) normalizedAlpha -= 360;
      if (normalizedAlpha < -180) normalizedAlpha += 360;
      
      const centerX = width / 2;
      const centerY = height / 2;
      
      // Dramatically increased sensitivity and range for more dramatic effect
      const gammaRange = 30; // Much more sensitive - smaller tilt = bigger movement
      const gammaNormalized = Math.max(-1, Math.min(1, deltaGamma / gammaRange));
      const targetX = centerX + gammaNormalized * width * 0.7; // Increased range to 70% of screen
      
      const betaRange = 35; // Much more sensitive
      const betaNormalized = Math.max(-1, Math.min(1, deltaBeta / betaRange));
      const targetY = centerY + betaNormalized * height * 0.7; // Increased range to 70% of screen
      
      const alphaInfluence = 0.3; // Increased from 0.2 for more dramatic rotation effect
      const alphaNormalized = Math.max(-1, Math.min(1, normalizedAlpha / 60)); // Much more sensitive
      
      gyroTarget.x = targetX + alphaNormalized * width * alphaInfluence;
      gyroTarget.y = targetY;
      
      gyroTarget.x = Math.max(0, Math.min(width, gyroTarget.x));
      gyroTarget.y = Math.max(0, Math.min(height, gyroTarget.y));
      
      const tiltMagnitude = Math.sqrt(
        deltaGamma * deltaGamma + deltaBeta * deltaBeta
      );
      const tiltDirectionX = deltaGamma !== 0 ? deltaGamma / Math.abs(deltaGamma) : 0;
      const tiltDirectionY = deltaBeta !== 0 ? deltaBeta / Math.abs(deltaBeta) : 0;
      
      gyroAcceleration.x = tiltDirectionX * tiltMagnitude * GYRO_LIQUID_CONFIG.tiltSensitivity;
      gyroAcceleration.y = tiltDirectionY * tiltMagnitude * GYRO_LIQUID_CONFIG.tiltSensitivity;
    }
    
      function updateGyroscopePhysics() {
        if (!useGyro || !gyroCalibrated) return;
      
      const dx = gyroTarget.x - gyroPosition.x;
      const dy = gyroTarget.y - gyroPosition.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      const springForceX = dx * GYRO_LIQUID_CONFIG.springStrength;
      const springForceY = dy * GYRO_LIQUID_CONFIG.springStrength;
      
      gyroVelocity.x += gyroAcceleration.x + springForceX;
      gyroVelocity.y += gyroAcceleration.y + springForceY;
      
      gyroVelocity.x *= GYRO_LIQUID_CONFIG.damping;
      gyroVelocity.y *= GYRO_LIQUID_CONFIG.damping;
      
      const velMag = Math.sqrt(gyroVelocity.x * gyroVelocity.x + gyroVelocity.y * gyroVelocity.y);
      if (velMag > GYRO_LIQUID_CONFIG.maxVelocity) {
        gyroVelocity.x = (gyroVelocity.x / velMag) * GYRO_LIQUID_CONFIG.maxVelocity;
        gyroVelocity.y = (gyroVelocity.y / velMag) * GYRO_LIQUID_CONFIG.maxVelocity;
      }
      
      gyroPosition.x += gyroVelocity.x;
      gyroPosition.y += gyroVelocity.y;
      
      const oscillationTime = time * GYRO_LIQUID_CONFIG.waveFrequency;
      const oscillationX = Math.sin(oscillationTime + gyroPosition.x * 0.01) * GYRO_LIQUID_CONFIG.waveAmplitude;
      const oscillationY = Math.cos(oscillationTime + gyroPosition.y * 0.01) * GYRO_LIQUID_CONFIG.waveAmplitude;
      
      const oscillationDamping = 1 - Math.min(velMag / GYRO_LIQUID_CONFIG.maxVelocity, 0.7);
      gyroPosition.x += oscillationX * oscillationDamping;
      gyroPosition.y += oscillationY * oscillationDamping;
      
      gyroPosition.x = Math.max(0, Math.min(width, gyroPosition.x));
      gyroPosition.y = Math.max(0, Math.min(height, gyroPosition.y));
      
      // Don't overwrite gyroTarget - it's set by handleDeviceOrientation based on device tilt
      // gyroPosition will smoothly follow gyroTarget through the physics simulation
    }

      // ============================================================================
      // Event Handlers
      // ============================================================================
      function handleMouseMove(e) {
      if (!useGyro) {
        targetMouse.x = e.clientX;
        targetMouse.y = e.clientY;
      }
    }

    function handleMouseLeave() {
      if (!useGyro) {
        targetMouse.x = -1000;
        targetMouse.y = -1000;
      }
    }

    function handleTouchMove(e) {
      if (!useGyro && e.touches.length > 0) {
        targetMouse.x = e.touches[0].clientX;
        targetMouse.y = e.touches[0].clientY;
      }
    }

    function handleTouchEnd() {
      if (!useGyro) {
        targetMouse.x = -1000;
        targetMouse.y = -1000;
      }
    }

      // ============================================================================
      // Initialization
      // ============================================================================
      
      // Page visibility handler - pause when hidden
      document.addEventListener('visibilitychange', function() {
        isPaused = document.hidden;
        if (!isPaused && !lastFrameTime) {
          // Resume animation
          requestAnimationFrame(render);
        }
      });

      // Webflow integration - cleanup on page navigation
      window.addEventListener('beforeunload', function() {
        // Cleanup intervals
        if (statusCheckInterval) {
          clearInterval(statusCheckInterval);
        }
        if (cleanupInterval) {
          clearInterval(cleanupInterval);
        }
      });

      // Event listener management - use AbortController for cleanup
      const abortController = new AbortController();
      const signal = abortController.signal;

      window.addEventListener('resize', resize, { signal });
      window.addEventListener('mousemove', handleMouseMove, { signal });
      window.addEventListener('mouseleave', handleMouseLeave, { signal });
      window.addEventListener('touchmove', handleTouchMove, { passive: true, signal });
      window.addEventListener('touchend', handleTouchEnd, { signal });
      
      // Detect iOS and permission requirements
      const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      const needsPermission = isIOS && typeof DeviceOrientationEvent !== 'undefined' && 
                              typeof DeviceOrientationEvent.requestPermission === 'function';
      
      log('Device detection:', {
        isIOS,
        isSafari,
        userAgent: navigator.userAgent,
        needsPermission,
        DeviceOrientationEvent: typeof DeviceOrientationEvent !== 'undefined',
        requestPermission: typeof DeviceOrientationEvent !== 'undefined' && 
                          typeof DeviceOrientationEvent.requestPermission === 'function',
        isLowEndDevice,
        hardwareConcurrency: navigator.hardwareConcurrency,
        deviceMemory: navigator.deviceMemory
      });
    
    if (!needsPermission) {
      // Non-iOS or older iOS - add listener immediately
      window.addEventListener('deviceorientation', handleDeviceOrientation, { passive: true });
    }
    
      // Check if device has gyroscope available
      function checkGyroscopeAvailability() {
        // Check if DeviceOrientationEvent is supported
        if (typeof DeviceOrientationEvent === 'undefined') {
          log('DeviceOrientationEvent not supported');
          return false;
        }
        
        // On iOS, we need to check if permission can be requested
        if (needsPermission) {
          // iOS devices typically have gyroscopes, so if we can request permission, assume it's available
          log('iOS device detected with permission API - assuming gyroscope available');
          return true;
        }
        
        // Check if we're on a touch device (which typically have gyroscopes)
        // This matches the CSS media query: (hover: none) and (pointer: coarse)
        const isTouchDevice = window.matchMedia && window.matchMedia('(hover: none) and (pointer: coarse)').matches;
        
        // Also check user agent for mobile devices
        const isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Desktop browsers (like Cursor/Chrome on desktop) don't have physical gyroscopes
        // Even if they support DeviceOrientationEvent API, they won't have real gyroscope data
        const hasGyroscope = isTouchDevice || isMobileUA;
        
        log('Gyroscope check details:', {
          isTouchDevice,
          isMobileUA,
          hasGyroscope,
          userAgent: navigator.userAgent
        });
        
        return hasGyroscope;
      }
      
      const hasGyroscope = checkGyroscopeAvailability();
      log('Gyroscope availability check:', hasGyroscope);
    
    // Gyroscope button setup
    const gyroBtn = document.getElementById('gyroBtn');
    const gyroControl = document.querySelector('.gyro-control');
    
    // Helper function to safely set button text (prevents "Disable Gyroscope" on mobile)
    const setGyroButtonText = (text) => {
      if (!gyroBtn) return;
      // Never show "Disable Gyroscope" on mobile devices
      if (hasGyroscope && text && text.toLowerCase().includes('disable')) {
        // On mobile, if gyroscope is validated, hide button instead
        if (gyroValidated && gyroControl) {
          gyroControl.style.setProperty('display', 'none', 'important');
          gyroControl.style.setProperty('visibility', 'hidden', 'important');
          gyroControl.style.setProperty('opacity', '0', 'important');
          gyroControl.style.setProperty('pointer-events', 'none', 'important');
          return;
        }
        // Otherwise, just don't set the text
        return;
      }
      gyroBtn.textContent = text;
    };
    
      // Hide gyroscope controls if device doesn't have gyroscope
      if (!hasGyroscope && gyroControl) {
        // Use setProperty with important to override CSS !important rules
        gyroControl.style.setProperty('display', 'none', 'important');
        log('Gyroscope not available, hiding controls');
      } else if (isIOS && hasGyroscope && gyroControl) {
        // Force button to be visible on iOS (if gyroscope is available)
        gyroControl.style.setProperty('display', 'block', 'important');
        log('Forced gyro button to be visible on iOS');
      }
      
      let statusCheckInterval = null;
      let cleanupInterval = null;
      
      if (gyroBtn) {
        log('Gyro button found, setting up');
        
      // Update button text for iOS
      if (needsPermission) {
        setGyroButtonText('Enable Gyroscope');
      }
      
      // Use both click and touchstart for better iOS compatibility
        const handleGyroClick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          log('Gyro button clicked, gyroEnabled:', gyroEnabled);
          
          if (!gyroEnabled) {
            if (needsPermission) {
              log('Requesting permission...');
              requestGyroPermission();
              setGyroButtonText('Requesting Permission...');
              gyroBtn.disabled = true;
            } else {
              enableGyroscope(true);
              setGyroButtonText('Enable Gyroscope');
            }
          } else {
            // On mobile devices, once gyroscope is enabled, don't allow disabling
            // This prevents accidental disabling and maintains better UX
            if (hasGyroscope) {
              log('Gyroscope enabled on mobile - disabling toggle to prevent accidental disable');
              return; // Don't allow disabling on mobile
            }
            
            // Desktop: allow toggle (mobile never reaches here due to early return above)
            useGyro = !useGyro;
            gyroBtn.classList.toggle('active', useGyro);
            setGyroButtonText(useGyro ? ' ' : 'Enable Gyroscope');
            
            if (!useGyro) {
              targetMouse.x = -1000;
              targetMouse.y = -1000;
            }
          }
        };
        
        gyroBtn.addEventListener('click', handleGyroClick, { signal });
        gyroBtn.addEventListener('touchend', handleGyroClick, { signal });
      
      const checkGyroStatus = () => {
        if (gyroEnabled && gyroCalibrated && gyroValidated) {
          if (!useGyro) {
            useGyro = true;
          }
          
          // On mobile devices, hide the button immediately once gyroscope is enabled and validated
          // This prevents users from accidentally disabling it and ensures "Disable Gyroscope" never appears
          if (hasGyroscope) {
            // Hide button immediately and prevent any text updates
            if (gyroControl) {
              gyroControl.style.setProperty('display', 'none', 'important');
              gyroControl.style.setProperty('visibility', 'hidden', 'important');
              gyroControl.style.setProperty('opacity', '0', 'important');
            }
            // Never set "Disable Gyroscope" text on mobile - button should be hidden
            log('Gyroscope enabled on mobile - hiding button to prevent disable');
            return; // Early return to prevent any further button updates on mobile
          }
          
          // Desktop: show button with toggle option
          gyroBtn.disabled = false;
          setGyroButtonText(useGyro ? ' ' : 'Enable Gyroscope');
          gyroBtn.classList.toggle('active', useGyro);
          if (gyroControl) {
            gyroControl.style.display = 'none';
          }
        } else if (gyroEnabled && gyroCalibrated && !gyroValidated) {
          // Only show "Validating..." if button is still visible (not hidden on mobile)
          if (!hasGyroscope) {
            gyroBtn.textContent = 'Validating...';
          }
        }
      };
      
      statusCheckInterval = setInterval(() => {
        if (gyroEnabled && gyroCalibrated) {
          checkGyroStatus();
          if (gyroValidated) {
            // On mobile, ensure button stays hidden after validation
            if (hasGyroscope && gyroControl) {
              gyroControl.style.setProperty('display', 'none', 'important');
              gyroControl.style.setProperty('visibility', 'hidden', 'important');
              gyroControl.style.setProperty('opacity', '0', 'important');
              gyroControl.style.setProperty('pointer-events', 'none', 'important');
            }
            clearInterval(statusCheckInterval);
            statusCheckInterval = null;
          }
        }
      }, 100);
      
        // Safety timeout: force validation after 5 seconds even if requirements aren't met
        setTimeout(() => {
          if (gyroEnabled && gyroCalibrated && !gyroValidated) {
            log('Validation timeout - forcing validation after 5 seconds');
            gyroValidated = true;
            useGyro = true;
            const gyroBtn = document.getElementById('gyroBtn');
            const gyroControl = document.querySelector('.gyro-control');
            
            if (gyroBtn) {
              // On mobile devices, hide the button immediately once gyroscope is enabled and validated
              // This prevents users from accidentally disabling it and ensures "Disable Gyroscope" never appears
              if (hasGyroscope) {
                // Hide button immediately with multiple CSS properties to ensure it's completely hidden
                if (gyroControl) {
                  gyroControl.style.setProperty('display', 'none', 'important');
                  gyroControl.style.setProperty('visibility', 'hidden', 'important');
                  gyroControl.style.setProperty('opacity', '0', 'important');
                  gyroControl.style.setProperty('pointer-events', 'none', 'important');
                }
                // Never set "Disable Gyroscope" text on mobile - button should be hidden
                log('Gyroscope validated on mobile (timeout) - hiding button to prevent disable');
              } else {
                // Desktop: show button with toggle option
                setGyroButtonText('Disable Gyroscope');
                gyroBtn.classList.add('active');
                gyroBtn.disabled = false;
                if (gyroControl) {
                  gyroControl.style.display = 'none';
                }
              }
            }
          }
        }, 5000);
      }
      
      function autoEnableGyroscope() {
      if (typeof DeviceOrientationEvent !== 'undefined') {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                         (window.matchMedia && window.matchMedia('(hover: none) and (pointer: coarse)').matches);
        
        if (isMobile && !needsPermission) {
          // Auto-enable for non-iOS mobile devices
          setTimeout(() => {
            enableGyroscope(true);
          }, 100);
        } else if (isIOS && needsPermission) {
          // On iOS, first check if permission is already granted
          const testHandler = (e) => {
            if (e.alpha !== null || e.beta !== null || e.gamma !== null) {
              log('iOS: Permission already granted, events are working');
              window.removeEventListener('deviceorientation', testHandler);
              enableGyroscope(true);
              window.addEventListener('deviceorientation', handleDeviceOrientation, { passive: true });
              const gyroBtn = document.getElementById('gyroBtn');
              const gyroControl = document.querySelector('.gyro-control');
              if (gyroBtn) {
                // On mobile, hide button once gyroscope is active
                if (hasGyroscope && gyroControl) {
                  // Hide button immediately with multiple CSS properties to ensure it's completely hidden
                  gyroControl.style.setProperty('display', 'none', 'important');
                  gyroControl.style.setProperty('visibility', 'hidden', 'important');
                  gyroControl.style.setProperty('opacity', '0', 'important');
                  gyroControl.style.setProperty('pointer-events', 'none', 'important');
                  log('Gyroscope active on mobile - hiding button');
                } else {
                  // Desktop: show active state
                  gyroBtn.textContent = 'Gyroscope Active';
                  gyroBtn.classList.add('active');
                }
              }
            }
          };
          
          // Check if permission already granted
          setTimeout(() => {
            window.addEventListener('deviceorientation', testHandler, { passive: true });
            // Remove test handler after 1 second if no events received
            setTimeout(() => {
              window.removeEventListener('deviceorientation', testHandler);
              // If no events, automatically request permission
              log('iOS: No deviceorientation events received, requesting permission automatically');
              requestGyroPermission();
              const gyroBtn = document.getElementById('gyroBtn');
              if (gyroBtn) {
                gyroBtn.textContent = 'Requesting Permission...';
                gyroBtn.disabled = true;
              }
            }, 1000);
          }, 500);
        }
      }
      }
      
      autoEnableGyroscope();
      
      // Automatically request gyroscope permission on first user interaction anywhere on the page
      // iOS requires a user gesture to request permission, so we trigger on any interaction
      if (needsPermission && typeof DeviceOrientationEvent !== 'undefined' && 
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        let permissionRequested = false;
        
        const requestOnInteraction = (e) => {
          log('Interaction event detected:', e.type, 'target:', e.target);
          
          // Only request if:
          // 1. Not already enabled (permission not granted yet)
          // 2. Not already requested in this session
          // 3. Permission wasn't already detected as granted
          if (!gyroEnabled && !permissionRequested) {
            permissionRequested = true;
            log('User interaction detected - automatically requesting gyroscope permission');
            log('Event details:', { type: e.type, target: e.target, currentTarget: e.currentTarget });
            
            // Update button state if button exists (optional)
            const gyroBtn = document.getElementById('gyroBtn');
            if (gyroBtn) {
              gyroBtn.textContent = 'Requesting Permission...';
              gyroBtn.disabled = true;
            }
            
            // Request permission (works independently of button)
            try {
              requestGyroPermission();
            } catch (error) {
              logError('Error in automatic permission request:', error);
              // Allow retry on error
              permissionRequested = false;
              // Update button if it exists (optional)
              if (gyroBtn) {
                gyroBtn.textContent = 'Enable Gyroscope';
                gyroBtn.disabled = false;
              }
            }
            
            // Clean up all listeners after first interaction attempt
            const events = ['touchstart', 'touchend', 'touchmove', 'pointerdown'];
            events.forEach(eventType => {
              window.removeEventListener(eventType, requestOnInteraction, { capture: true });
              document.removeEventListener(eventType, requestOnInteraction, { capture: true });
              document.body.removeEventListener(eventType, requestOnInteraction, { capture: true });
              const container = document.querySelector('.container');
              if (container) {
                container.removeEventListener(eventType, requestOnInteraction, { capture: true });
              }
            });
          } else if (gyroEnabled) {
            // Permission already granted, clean up listeners
            log('Gyroscope already enabled, skipping permission request');
            const events = ['touchstart', 'touchend', 'touchmove', 'pointerdown'];
            events.forEach(eventType => {
              window.removeEventListener(eventType, requestOnInteraction, { capture: true });
              document.removeEventListener(eventType, requestOnInteraction, { capture: true });
              document.body.removeEventListener(eventType, requestOnInteraction, { capture: true });
              const container = document.querySelector('.container');
              if (container) {
                container.removeEventListener(eventType, requestOnInteraction, { capture: true });
              }
            });
          } else if (permissionRequested) {
            log('Permission already requested in this session, skipping');
          }
        };
        
        // Listen for any touch interaction anywhere on the page
        // Using touch-specific event types for mobile devices
        const interactionEvents = [
          'touchstart',   // Touch start - primary touch event
          'touchend',     // Touch end - when finger lifts
          'touchmove',    // Touch move - in case start/end are prevented
          'pointerdown'   // Pointer events (covers touch, pen, etc. on modern browsers)
        ];
        
        // Set up automatic permission request on user interaction
        // This works completely independently of the button - no button required
        if (!gyroEnabled) {
          log('Setting up automatic gyroscope permission request on user interaction');
          log('needsPermission:', needsPermission);
          log('gyroEnabled:', gyroEnabled);
          
          interactionEvents.forEach(eventType => {
            // Add to both window and document to catch all interactions
            // Use capture phase to catch events before they reach other handlers
            window.addEventListener(eventType, requestOnInteraction, { once: true, passive: true, capture: true });
            document.addEventListener(eventType, requestOnInteraction, { once: true, passive: true, capture: true });
            // Also add to body and the container to catch all possible interactions
            document.body.addEventListener(eventType, requestOnInteraction, { once: true, passive: true, capture: true });
            const container = document.querySelector('.container');
            if (container) {
              container.addEventListener(eventType, requestOnInteraction, { once: true, passive: true, capture: true });
            }
          });
          
          log('Automatic permission request listeners attached to:', {
            window: true,
            document: true,
            body: true,
            container: !!document.querySelector('.container')
          });
        } else {
          log('Gyroscope already enabled, skipping automatic permission request setup');
        }
        
        // Also set up a check to clean up listeners if permission gets granted elsewhere
        const checkAndCleanup = () => {
          if (gyroEnabled) {
            const events = ['touchstart', 'touchend', 'touchmove', 'pointerdown'];
            events.forEach(eventType => {
              window.removeEventListener(eventType, requestOnInteraction, { capture: true });
              document.removeEventListener(eventType, requestOnInteraction, { capture: true });
              document.body.removeEventListener(eventType, requestOnInteraction, { capture: true });
              const container = document.querySelector('.container');
              if (container) {
                container.removeEventListener(eventType, requestOnInteraction, { capture: true });
              }
            });
          }
        };
        
        // Check periodically and clean up if permission is granted
        cleanupInterval = setInterval(() => {
          if (gyroEnabled) {
            checkAndCleanup();
            clearInterval(cleanupInterval);
          }
        }, 500);
        
        // Also clean up after a reasonable timeout (10 seconds)
        setTimeout(() => {
          if (cleanupInterval) {
            clearInterval(cleanupInterval);
          }
        }, 10000);
        }
      
      // Initialize
      resize();
      requestAnimationFrame(render);
      
      // Log button visibility for debugging
      if (DEBUG) {
        setTimeout(() => {
          const gyroBtn = document.getElementById('gyroBtn');
          const gyroControl = document.querySelector('.gyro-control');
          if (gyroBtn) {
            const rect = gyroBtn.getBoundingClientRect();
            log('Button visibility check:', {
              display: window.getComputedStyle(gyroControl).display,
              visible: rect.width > 0 && rect.height > 0,
              position: { x: rect.x, y: rect.y, width: rect.width, height: rect.height },
              zIndex: window.getComputedStyle(gyroControl).zIndex
            });
          }
        }, 1000);
      }
      }
    })();
  </script>
</body>
</html>