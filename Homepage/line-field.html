<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Line Field</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0506; height: 100vh; margin: 0; overflow: hidden; }
    .container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; }
    canvas { display: block; width: 100%; height: 100%; }
  </style>
</head>
<body>
  <div class="container"><canvas id="canvas"></canvas></div>
  <script>
    'use strict';

    // ============================================================================
    // Configuration
    // ============================================================================
    const CONFIG = {
      pointsPerLine: 60,
      color: { r: 253, g: 87, b: 75 },
      lineWidth: 0.5,
      cursorRadius: 180,
      dragStrength: 16,
      baseStrength: 300,
      wakeLength: 200,
      wakeLengthSquared: 200 * 200, // Pre-calculated for distance comparisons
      velocitySmoothing: 0.15,
      mouseSmoothing: 0.12,
      noiseTimeScale: 0.0000008,
      noiseAmplitude: 8,
      driftSpeed: 0.00000002,
      driftAmplitude: 4,
      driftWaveLength: 0.008,
      vanishingPointY: 0.95,
      // Performance thresholds
      minVelocityForWake: 0.3,
      maxCursorDistance: 600,
      maxCursorDistanceSquared: 600 * 600,
      easeFactorMin: 0.002,
      easeFactorMax: 0.02,
      easeFactorDivisor: 800,
      // Fluidity enhancements
      springStrength: 0.15,        // Connection between adjacent points
      springDamping: 0.85,          // Damping for spring effect
      waveInfluence: 0.08,          // How much nearby lines influence each other
      waveRadius: 80,               // Distance for wave propagation
      waveRadiusSquared: 80 * 80,
      verticalFlow: 0.3,            // Subtle downward current
      flowSpeed: 0.00001,           // Speed of vertical flow
      pointVelocityDamping: 0.92,    // Momentum persistence
      curlStrength: 0.4,            // Rotation effect around cursor
      turbulenceScale: 0.003        // Additional noise for turbulence
    };

    // ============================================================================
    // Canvas Setup
    // ============================================================================
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    
    // Cache color string to avoid string concatenation in render loop
    const strokeColor = `rgba(${CONFIG.color.r},${CONFIG.color.g},${CONFIG.color.b},0.85)`;
    const bgColor = '#0a0506';

    // ============================================================================
    // Noise Generator (Simplex Noise)
    // ============================================================================
    const noise = (() => {
      const perm = new Uint8Array(512);
      for (let i = 0; i < 256; i++) {
        perm[i] = perm[i + 256] = Math.floor(Math.random() * 256);
      }
      
      const grad3 = [
        [1,1,0], [-1,1,0], [1,-1,0], [-1,-1,0],
        [1,0,1], [-1,0,1], [1,0,-1], [-1,0,-1],
        [0,1,1], [0,-1,1], [0,1,-1], [0,-1,-1]
      ];
      
      const dot = (g, x, y) => g[0] * x + g[1] * y;
      const fade = (t) => t * t * t * (t * (t * 6 - 15) + 10);
      const lerp = (a, b, t) => a + t * (b - a);
      
      return (x, y) => {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        
        const u = fade(x);
        const v = fade(y);
        const A = perm[X] + Y;
        const B = perm[X + 1] + Y;
        
        return lerp(
          lerp(
            dot(grad3[perm[A] % 12], x, y),
            dot(grad3[perm[B] % 12], x - 1, y),
            u
          ),
          lerp(
            dot(grad3[perm[A + 1] % 12], x, y - 1),
            dot(grad3[perm[B + 1] % 12], x - 1, y - 1),
            u
          ),
          v
        );
      };
    })();

    // ============================================================================
    // State Management
    // ============================================================================
    let width = 0;
    let height = 0;
    let lines = [];
    
    const mouse = { x: -1000, y: -1000 };
    const targetMouse = { x: -1000, y: -1000 };
    const prevMouse = { x: -1000, y: -1000 };
    const velocity = { x: 0, y: 0 };
    
    let time = 0;
    const vanishingPoint = { x: 0, y: 0 };
    
    // Cursor simulation state
    let cursorSimulation = {
      active: false,
      startTime: 0,
      duration: 30000, // 30 seconds
      waypoints: [],
      currentPathIndex: 0,
      pathProgress: 0,
      isUserControlling: false
    };

    // ============================================================================
    // Cursor Path Simulation
    // ============================================================================
    function generateCursorPath() {
      const waypointCount = 8 + Math.floor(Math.random() * 5); // 8-12 waypoints
      const waypoints = [];
      const margin = 100; // Keep cursor away from edges
      
      for (let i = 0; i < waypointCount; i++) {
        waypoints.push({
          x: margin + Math.random() * (width - margin * 2),
          y: margin + Math.random() * (height - margin * 2),
          // Vary speed between waypoints for natural feel
          duration: 2000 + Math.random() * 3000 // 2-5 seconds per segment
        });
      }
      
      return waypoints;
    }
    
    function easeInOutCubic(t) {
      return t < 0.5
        ? 4 * t * t * t
        : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }
    
    function updateCursorSimulation(currentTime) {
      if (!cursorSimulation.active || cursorSimulation.isUserControlling) return;
      
      const elapsed = currentTime - cursorSimulation.startTime;
      
      // Check if simulation should end and restart
      if (elapsed >= cursorSimulation.duration) {
        // Restart with a new path
        cursorSimulation.waypoints = generateCursorPath();
        cursorSimulation.startTime = currentTime;
        cursorSimulation.currentPathIndex = 0;
        cursorSimulation.pathProgress = 0;
        
        // Start at first waypoint
        if (cursorSimulation.waypoints.length > 0) {
          targetMouse.x = cursorSimulation.waypoints[0].x;
          targetMouse.y = cursorSimulation.waypoints[0].y;
        }
        return;
      }
      
      // Calculate which path segment we're on
      let accumulatedTime = 0;
      let segmentIndex = 0;
      
      for (let i = 0; i < cursorSimulation.waypoints.length - 1; i++) {
        const segmentDuration = cursorSimulation.waypoints[i].duration;
        if (elapsed < accumulatedTime + segmentDuration) {
          segmentIndex = i;
          break;
        }
        accumulatedTime += segmentDuration;
      }
      
      // Get current and next waypoint
      const currentWaypoint = cursorSimulation.waypoints[segmentIndex];
      const nextWaypoint = cursorSimulation.waypoints[segmentIndex + 1];
      
      if (!nextWaypoint) {
        // Last waypoint - hold position briefly then restart or end
        targetMouse.x = currentWaypoint.x;
        targetMouse.y = currentWaypoint.y;
        return;
      }
      
      // Calculate progress through current segment (0 to 1)
      const segmentElapsed = elapsed - accumulatedTime;
      const segmentProgress = Math.min(segmentElapsed / currentWaypoint.duration, 1);
      
      // Apply easing for smooth motion
      const easedProgress = easeInOutCubic(segmentProgress);
      
      // Interpolate between waypoints
      targetMouse.x = currentWaypoint.x + (nextWaypoint.x - currentWaypoint.x) * easedProgress;
      targetMouse.y = currentWaypoint.y + (nextWaypoint.y - currentWaypoint.y) * easedProgress;
    }
    
    function startCursorSimulation() {
      if (cursorSimulation.active) return;
      
      cursorSimulation.waypoints = generateCursorPath();
      cursorSimulation.startTime = performance.now();
      cursorSimulation.active = true;
      cursorSimulation.currentPathIndex = 0;
      cursorSimulation.pathProgress = 0;
      
      // Start at first waypoint
      if (cursorSimulation.waypoints.length > 0) {
        targetMouse.x = cursorSimulation.waypoints[0].x;
        targetMouse.y = cursorSimulation.waypoints[0].y;
      }
    }

    // ============================================================================
    // Line Initialization
    // ============================================================================
    function initLines() {
      lines = [];
      
      // Calculate target line count (40% more than original)
      const originalLineCount = 200; // Approximate base count
      const targetLineCount = Math.ceil(originalLineCount * 1.4);
      const spacing = width / (targetLineCount + 1);
      
      const pointsPerLine = CONFIG.pointsPerLine;
      const pointStep = 1 / (pointsPerLine - 1);
      
      for (let i = 0; i < targetLineCount; i++) {
        const canvasX = spacing * (i + 1);
        const normalizedX = (i + 1) / (targetLineCount + 1);
        
        const line = {
          points: [],
          restPoints: [],
          index: i,
          normalizedX
        };
        
        // Pre-calculate point positions
        for (let j = 0; j < pointsPerLine; j++) {
          const t = j * pointStep;
          const y = t * height;
          const point = { x: canvasX, y, vx: 0, vy: 0 }; // Add velocity for momentum
          const restPoint = { x: canvasX, y, normalizedY: t };
          
          line.points.push(point);
          line.restPoints.push(restPoint);
        }
        
        lines.push(line);
      }
    }

    // ============================================================================
    // Resize Handler
    // ============================================================================
    function resize() {
      const dpr = window.devicePixelRatio || 1;
      width = window.innerWidth;
      height = window.innerHeight;
      
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;
      
      ctx.scale(dpr, dpr);
      vanishingPoint.x = width / 2;
      vanishingPoint.y = height * CONFIG.vanishingPointY;
      
      initLines();
      
      // Regenerate cursor path on resize if simulation is active
      if (cursorSimulation.active && !cursorSimulation.isUserControlling) {
        cursorSimulation.waypoints = generateCursorPath();
        cursorSimulation.startTime = performance.now();
      }
    }

    // ============================================================================
    // Point Update Logic
    // ============================================================================
    function updatePoints() {
      // Update cursor simulation if active
      updateCursorSimulation(performance.now());
      
      // Update mouse position with smoothing
      prevMouse.x = mouse.x;
      prevMouse.y = mouse.y;
      mouse.x += (targetMouse.x - mouse.x) * CONFIG.mouseSmoothing;
      mouse.y += (targetMouse.y - mouse.y) * CONFIG.mouseSmoothing;
      
      // Update velocity
      const mouseDeltaX = mouse.x - prevMouse.x;
      const mouseDeltaY = mouse.y - prevMouse.y;
      velocity.x += (mouseDeltaX - velocity.x) * CONFIG.velocitySmoothing;
      velocity.y += (mouseDeltaY - velocity.y) * CONFIG.velocitySmoothing;
      
      // Pre-calculate time-based values
      const timeNoiseX = time * CONFIG.noiseTimeScale;
      const timeNoiseY = timeNoiseX * 0.7;
      const timeDrift = time * CONFIG.driftSpeed * 1000;
      const velMagSquared = velocity.x * velocity.x + velocity.y * velocity.y;
      const velMag = Math.sqrt(velMagSquared);
      const hasVelocity = velMag > CONFIG.minVelocityForWake;
      
      // Cache constants
      const wakeLength = CONFIG.wakeLength;
      const wakeLengthSquared = CONFIG.wakeLengthSquared;
      const maxCursorDistSquared = CONFIG.maxCursorDistanceSquared;
      const noiseAmp = CONFIG.noiseAmplitude;
      const driftAmp = CONFIG.driftAmplitude;
      const baseStrength = CONFIG.baseStrength;
      const dragStrength = CONFIG.dragStrength;
      
      // Pre-calculate vertical flow effect
      const verticalFlowOffset = Math.sin(time * CONFIG.flowSpeed) * CONFIG.verticalFlow;
      
      // Update each line
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const normalizedX = line.normalizedX;
        const noiseX = normalizedX * 3 + timeNoiseX;
        
        // Pre-calculate noise and drift for this line
        const driftBase = Math.sin(normalizedX * Math.PI * 6 + timeDrift) * driftAmp;
        
        // Get neighboring lines for wave influence
        const prevLine = i > 0 ? lines[i - 1] : null;
        const nextLine = i < lines.length - 1 ? lines[i + 1] : null;
        const waveStrength = CONFIG.waveInfluence;
        
        // Update each point in the line
        for (let j = 0; j < line.points.length; j++) {
          const rest = line.restPoints[j];
          const point = line.points[j];
          
          // Calculate wave influence from neighboring lines at this point height
          let neighborInfluenceX = 0;
          if (prevLine && nextLine && j < prevLine.points.length && j < nextLine.points.length) {
            const prevPoint = prevLine.points[j];
            const nextPoint = nextLine.points[j];
            const dxPrev = prevPoint.x - rest.x;
            const dxNext = nextPoint.x - rest.x;
            neighborInfluenceX = (dxPrev + dxNext) * waveStrength * 0.5;
          }
          
          // Calculate ambient noise effect with turbulence
          const noiseVal = noise(noiseX, rest.normalizedY * 2 + timeNoiseY);
          const turbulenceVal = noise(
            normalizedX * 5 + time * CONFIG.turbulenceScale,
            rest.normalizedY * 3 + time * CONFIG.turbulenceScale * 0.5
          ) * 0.3;
          
          // Distance from cursor (using squared distance to avoid sqrt)
          const dxFromCursor = rest.x - mouse.x;
          const dyFromCursor = rest.y - mouse.y;
          const distFromCursorSquared = dxFromCursor * dxFromCursor + dyFromCursor * dyFromCursor;
          
          // Ambient effect (only calculate if cursor is nearby)
          let ambientX = 0;
          let ambientY = verticalFlowOffset; // Add vertical flow
          
          if (distFromCursorSquared < maxCursorDistSquared) {
            const distFromCursor = Math.sqrt(distFromCursorSquared);
            const ambientScale = 0.3 + (1 - distFromCursor / CONFIG.maxCursorDistance) * 2;
            const dirX = distFromCursor > 0 ? dxFromCursor / distFromCursor : 0;
            const dirY = distFromCursor > 0 ? dyFromCursor / distFromCursor : 0;
            
            // Add curl/rotation effect around cursor
            const curlAngle = Math.atan2(dyFromCursor, dxFromCursor) + Math.PI / 2;
            const curlX = Math.cos(curlAngle) * CONFIG.curlStrength * ambientScale;
            const curlY = Math.sin(curlAngle) * CONFIG.curlStrength * ambientScale;
            
            ambientX = (noiseVal * noiseAmp + driftBase + turbulenceVal) * ambientScale * dirX + curlX;
            ambientY += curlY * 0.5;
          } else {
            // Subtle ambient flow even when cursor is far
            ambientX = (noiseVal * noiseAmp + driftBase + turbulenceVal) * 0.3;
          }
          
          // Add wave influence from neighbors
          ambientX += neighborInfluenceX;
          
          // Calculate drag effect
          const dx = rest.x - mouse.x;
          const dy = rest.y - mouse.y;
          const distSquared = dx * dx + dy * dy;
          
          let dragOffsetX = 0;
          let dragOffsetY = 0;
          
          if (distSquared < wakeLengthSquared && hasVelocity) {
            const dist = Math.sqrt(distSquared);
            const distFalloff = Math.pow(1 - dist / wakeLength, 2);
            
            const invDist = 1 / Math.max(dist, 1);
            const pushX = dx * invDist;
            const pushY = dy * invDist;
            
            const dragInfluence = Math.min(velMag / 5, 1);
            const invVelMag = 1 / velMag;
            const blendedX = pushX * (1 - dragInfluence * 0.7) + velocity.x * invVelMag * dragInfluence;
            const blendedY = pushY * (1 - dragInfluence * 0.7) + velocity.y * invVelMag * dragInfluence;
            
            const velFactor = Math.min(velMag / 4, 1);
            const strength = (baseStrength * velFactor * velFactor + velMag * dragStrength) * distFalloff;
            
            dragOffsetX = blendedX * strength;
            dragOffsetY = blendedY * strength * 0.4;
          }
          
          // Calculate target position
          const targetX = rest.x + ambientX + dragOffsetX;
          const targetY = rest.y + ambientY + dragOffsetY;
          
          // Spring connection to adjacent points for fluidity
          let springForceX = 0;
          let springForceY = 0;
          
          if (j > 0) {
            const prevPoint = line.points[j - 1];
            const springDX = prevPoint.x - point.x;
            const springDY = prevPoint.y - point.y;
            springForceX += springDX * CONFIG.springStrength;
            springForceY += springDY * CONFIG.springStrength;
          }
          
          if (j < line.points.length - 1) {
            const nextPoint = line.points[j + 1];
            const springDX = nextPoint.x - point.x;
            const springDY = nextPoint.y - point.y;
            springForceX += springDX * CONFIG.springStrength;
            springForceY += springDY * CONFIG.springStrength;
          }
          
          // Apply momentum (velocity persistence)
          point.vx *= CONFIG.pointVelocityDamping;
          point.vy *= CONFIG.pointVelocityDamping;
          
          // Calculate forces
          const diffX = targetX - point.x;
          const diffY = targetY - point.y;
          const diffSquared = diffX * diffX + diffY * diffY;
          const diffMag = Math.sqrt(diffSquared);
          
          // Adaptive easing for smoother motion
          const easeFactor = CONFIG.easeFactorMin + Math.min(diffMag / CONFIG.easeFactorDivisor, CONFIG.easeFactorMax);
          
          // Add spring forces to velocity
          point.vx += (diffX * easeFactor + springForceX) * (1 - CONFIG.springDamping);
          point.vy += (diffY * easeFactor + springForceY) * (1 - CONFIG.springDamping);
          
          // Apply velocity with damping
          point.x += point.vx;
          point.y += point.vy;
          
          // Also apply direct easing for responsiveness
          point.x += diffX * easeFactor * CONFIG.springDamping;
          point.y += diffY * easeFactor * CONFIG.springDamping;
        }
      }
    }

    // ============================================================================
    // Rendering
    // ============================================================================
    function drawLine(points) {
      if (points.length < 2) return;
      
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = CONFIG.lineWidth;
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      
      const lastIndex = points.length - 1;
      for (let i = 1; i < lastIndex; i++) {
        const current = points[i];
        const next = points[i + 1];
        const midX = (current.x + next.x) * 0.5;
        const midY = (current.y + next.y) * 0.5;
        ctx.quadraticCurveTo(current.x, current.y, midX, midY);
      }
      
      const last = points[lastIndex];
      ctx.lineTo(last.x, last.y);
      ctx.stroke();
    }

    function render(timestamp) {
      time = timestamp;
      
      // Clear canvas
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, width, height);
      
      // Update and draw
      updatePoints();
      
      for (let i = 0; i < lines.length; i++) {
        drawLine(lines[i].points);
      }
      
      requestAnimationFrame(render);
    }

    // ============================================================================
    // Event Handlers
    // ============================================================================
    function handleMouseMove(e) {
      cursorSimulation.isUserControlling = true;
      cursorSimulation.active = false; // Stop simulation when user takes control
      targetMouse.x = e.clientX;
      targetMouse.y = e.clientY;
    }

    function handleMouseLeave() {
      cursorSimulation.isUserControlling = false;
      targetMouse.x = -1000;
      targetMouse.y = -1000;
      // Optionally restart simulation after a delay
      setTimeout(() => {
        if (!cursorSimulation.isUserControlling) {
          startCursorSimulation();
        }
      }, 2000);
    }

    function handleTouchMove(e) {
      cursorSimulation.isUserControlling = true;
      cursorSimulation.active = false;
      if (e.touches.length > 0) {
        targetMouse.x = e.touches[0].clientX;
        targetMouse.y = e.touches[0].clientY;
      }
    }

    function handleTouchEnd() {
      cursorSimulation.isUserControlling = false;
      targetMouse.x = -1000;
      targetMouse.y = -1000;
      setTimeout(() => {
        if (!cursorSimulation.isUserControlling) {
          startCursorSimulation();
        }
      }, 2000);
    }

    // ============================================================================
    // Initialization
    // ============================================================================
    window.addEventListener('resize', resize);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseleave', handleMouseLeave);
    window.addEventListener('touchmove', handleTouchMove, { passive: true });
    window.addEventListener('touchend', handleTouchEnd);

    resize();
    
    // Start cursor simulation after a brief delay
    setTimeout(() => {
      startCursorSimulation();
    }, 1000);
    
    requestAnimationFrame(render);
  </script>
</body>
</html>